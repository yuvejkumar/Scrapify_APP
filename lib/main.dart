// main.dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart'; // Import Firebase Core
import 'package:firebase_auth/firebase_auth.dart'; // Import Firebase Auth
import 'package:cloud_firestore/cloud_firestore.dart'; // Import Cloud Firestore

// You need a firebase_options.dart file generated by the FlutterFire CLI
import 'firebase_options.dart';

// --- MAIN FUNCTION (MODIFIED) ---
void main() async {
  // Ensure that Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();
  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const SmartScrapPickupApp());
}

class SmartScrapPickupApp extends StatelessWidget {
  const SmartScrapPickupApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Smart Scrap Pickup',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.green,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      // The SplashScreen will handle navigation
      home: const SplashScreen(),
    );
  }
}

// --- SPLASH SCREEN (MODIFIED FOR FIREBASE AUTH) ---
class SplashScreen extends StatefulWidget {
  const SplashScreen({Key? key}) : super(key: key);

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _navigateBasedOnAuth();
  }

  Future<void> _navigateBasedOnAuth() async {
    // Listen to authentication state changes
    FirebaseAuth.instance.authStateChanges().listen((User? user) async {
      // Delay for splash screen visibility
      await Future.delayed(const Duration(seconds: 2));

      if (!mounted) return;

      if (user == null) {
        // No user is signed in, go to LoginScreen
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (_) => const LoginScreen()),
        );
      } else {
        // User is signed in, check their role from Firestore
        try {
          final userDoc = await FirebaseFirestore.instance
              .collection('users')
              .doc(user.uid)
              .get();

          if (userDoc.exists) {
            final role = userDoc.data()?['role'];
            if (role == 'Customer') {
              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (_) => const CustomerHomeScreen()),
              );
            } else {
              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (_) => const CaptainHomeScreen()),
              );
            }
          } else {
            // Document doesn't exist, something is wrong, log them out
            await FirebaseAuth.instance.signOut();
             Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (_) => const LoginScreen()),
            );
          }
        } catch (e) {
          // Error fetching document, log out and go to login
          await FirebaseAuth.instance.signOut();
           Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (_) => const LoginScreen()),
            );
        }
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    // Your beautiful splash screen UI remains the same!
    return Scaffold(
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Colors.green.shade400, Colors.green.shade800],
          ),
        ),
        child: const Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.recycling, size: 100, color: Colors.white),
              SizedBox(height: 20),
              Text(
                'Smart Scrap Pickup',
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
              SizedBox(height: 10),
              Text(
                'Recycle Responsibly',
                style: TextStyle(fontSize: 16, color: Colors.white70),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// --- LOGIN SCREEN (MODIFIED FOR FIREBASE AUTH) ---
class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;
  bool _isLoading = false;

  Future<void> _login() async {
    if (_emailController.text.trim().isEmpty ||
        _passwordController.text.trim().isEmpty) {
      _showMessage('Please fill all fields');
      return;
    }
    setState(() => _isLoading = true);

    try {
      // Use Firebase Auth to sign in
      final userCredential =
          await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );

      // If login is successful, the authStateChanges listener in SplashScreen
      // will handle the navigation automatically. You don't need to do it here.
      // However, for immediate feedback and to avoid a flicker, we can navigate directly.
      if (userCredential.user != null && mounted) {
        // Fetch user role from Firestore
        final userDoc = await FirebaseFirestore.instance
            .collection('users')
            .doc(userCredential.user!.uid)
            .get();
        final role = userDoc.data()?['role'];

        if (role == 'Customer') {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (_) => const CustomerHomeScreen()),
          );
        } else {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (_) => const CaptainHomeScreen()),
          );
        }
      }
    } on FirebaseAuthException catch (e) {
      // Handle specific Firebase auth errors
      String message = 'An error occurred. Please try again.';
      if (e.code == 'user-not-found') {
        message = 'No user found for that email.';
      } else if (e.code == 'wrong-password') {
        message = 'Wrong password provided.';
      } else if (e.code == 'invalid-email') {
        message = 'The email address is not valid.';
      }
      _showMessage(message);
    } catch (e) {
      // Handle other errors
      _showMessage('Failed to login: $e');
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  void _showMessage(String msg) {
    ScaffoldMessenger.of(context)
        .showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    // UI remains the same, but we add a loading indicator
    return Scaffold(
      appBar: AppBar(title: const Text('Login'), centerTitle: true),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // ... your existing UI widgets ...
            const SizedBox(height: 40),
            Icon(Icons.recycling, size: 80, color: Colors.green.shade700),
            const SizedBox(height: 20),
            const Text(
              'Welcome Back!',
              textAlign: TextAlign.center,
              style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 40),
            TextField(
              controller: _emailController,
              decoration: const InputDecoration(
                labelText: 'Email',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.email),
              ),
              keyboardType: TextInputType.emailAddress,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _passwordController,
              decoration: InputDecoration(
                labelText: 'Password',
                border: const OutlineInputBorder(),
                prefixIcon: const Icon(Icons.lock),
                suffixIcon: IconButton(
                  icon: Icon(_obscurePassword
                      ? Icons.visibility_off
                      : Icons.visibility),
                  onPressed: () {
                    setState(() {
                      _obscurePassword = !_obscurePassword;
                    });
                  },
                ),
              ),
              obscureText: _obscurePassword,
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isLoading ? null : _login,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
              child: _isLoading
                  ? const CircularProgressIndicator(color: Colors.white)
                  : const Text('Login', style: TextStyle(fontSize: 18)),
            ),
            const SizedBox(height: 16),
            TextButton(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => const SignupScreen()),
                );
              },
              child: const Text('Don\'t have an account? Sign Up'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}


class SignupScreen extends StatefulWidget {
  const SignupScreen({Key? key}) : super(key: key);

  @override
  State<SignupScreen> createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _nameController = TextEditingController();
  final _formKey = GlobalKey<FormState>();

  String _selectedRole = 'Customer';
  String? _selectedCity; // Nullable to show hint text initially
  bool _obscurePassword = true;
  bool _isLoading = false;

  // List of cities for the dropdown
  final List<String> _cities = const [
    'Mumbai', 'Delhi', 'Bangalore', 'Kolkata', 'Chennai',
    'Hyderabad', 'Pune', 'Ahmedabad', 'Surat', 'Jaipur',
    'Lucknow', 'Kanpur', 'Nagpur', 'Indore', 'Thane'
  ];

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _nameController.dispose();
    super.dispose();
  }

  Future<void> _signup() async {
    // Validate the form, including the new city dropdown
    if (!_formKey.currentState!.validate()) {
      _showMessage('Please fill all required fields');
      return;
    }

    setState(() => _isLoading = true);

    try {
      // Step 1: Create user in Firebase Authentication
      final userCredential =
          await FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );
      
      final user = userCredential.user;
      if (user == null) {
          throw Exception("User creation failed.");
      }

      // Step 2: Create a user document in Firestore with city information
      await FirebaseFirestore.instance.collection('users').doc(user.uid).set({
        'uid': user.uid,
        'email': _emailController.text.trim(),
        'name': _nameController.text.trim(),
        'role': _selectedRole,
        'city': _selectedCity, // Save the selected city
        'phone': '',
        'address': '',
        'pincode': '',
        'createdAt': FieldValue.serverTimestamp(),
      });
      
      _showMessage('Signup successful! Please login.');
      if (mounted) Navigator.pop(context);

    } on FirebaseAuthException catch (e) {
      String message = 'An error occurred.';
      if (e.code == 'weak-password') {
        message = 'The password provided is too weak.';
      } else if (e.code == 'email-already-in-use') {
        message = 'An account already exists for that email.';
      }
      _showMessage(message);
    } catch (e) {
      _showMessage('Signup failed: $e');
    } finally {
       if (mounted) setState(() => _isLoading = false);
    }
  }

  void _showMessage(String msg) {
    ScaffoldMessenger.of(context)
        .showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Sign Up'), centerTitle: true),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const SizedBox(height: 20),
              const Text(
                'Create Account',
                textAlign: TextAlign.center,
                style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 30),
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Full Name',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) => value == null || value.isEmpty ? 'Please enter your name' : null,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _emailController,
                decoration: const InputDecoration(
                  labelText: 'Email',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
                validator: (value) {
                  if (value == null || value.isEmpty || !value.contains('@')) {
                    return 'Please enter a valid email';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'Password',
                  border: const OutlineInputBorder(),
                  prefixIcon: const Icon(Icons.lock),
                  suffixIcon: IconButton(
                    icon: Icon(_obscurePassword ? Icons.visibility_off : Icons.visibility),
                    onPressed: () => setState(() => _obscurePassword = !_obscurePassword),
                  ),
                ),
                obscureText: _obscurePassword,
                validator: (value) => value == null || value.length < 6 ? 'Password must be at least 6 characters' : null,
              ),
              const SizedBox(height: 16),

              // --- CITY DROPDOWN ---
              DropdownButtonFormField<String>(
                value: _selectedCity,
                isExpanded: true,
                decoration: const InputDecoration(
                  labelText: 'City',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.location_city),
                ),
                hint: const Text('Select Your City'),
                items: _cities.map((String city) {
                  return DropdownMenuItem<String>(
                    value: city,
                    child: Text(city),
                  );
                }).toList(),
                onChanged: (value) {
                  setState(() {
                    _selectedCity = value;
                  });
                },
                validator: (value) => value == null ? 'Please select a city' : null,
              ),
              // --- END CITY DROPDOWN ---
              
              const SizedBox(height: 16),
              DropdownButtonFormField<String>(
                value: _selectedRole,
                decoration: const InputDecoration(
                  labelText: 'Role',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.person_outline),
                ),
                items: const [
                  DropdownMenuItem(value: 'Customer', child: Text('Customer')),
                  DropdownMenuItem(value: 'Captain', child: Text('Captain')),
                ],
                onChanged: (value) {
                  setState(() {
                    _selectedRole = value!;
                  });
                },
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: _isLoading ? null : _signup,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: _isLoading
                    ? const CircularProgressIndicator(color: Colors.white)
                    : const Text('Sign Up', style: TextStyle(fontSize: 18)),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// ... CustomerHomeScreen remains the same ...
// --- Enhanced Customer Home Screen ---
class CustomerHomeScreen extends StatefulWidget {
  const CustomerHomeScreen({Key? key}) : super(key: key);

  @override
  State<CustomerHomeScreen> createState() => _CustomerHomeScreenState();
}

class _CustomerHomeScreenState extends State<CustomerHomeScreen> {
  int _selectedIndex = 0;

  // The pages are now constant, improving performance slightly
  static const List<Widget> _pages = [
    CustomerDashboard(),
    CustomerPickupsScreen(),
    CustomerProfileScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    // UI Enhancement: Define colors for a consistent theme
    final Color primaryColor = Colors.green.shade800;
    final Color accentColor = Colors.green.shade100;

    return Theme(
      // UI Enhancement: Apply a custom theme to the NavigationBar
      data: Theme.of(context).copyWith(
        navigationBarTheme: NavigationBarThemeData(
          backgroundColor: Colors.white,
          indicatorColor: accentColor,
          labelTextStyle: MaterialStateProperty.resolveWith<TextStyle>(
            (states) => states.contains(MaterialState.selected)
                ? TextStyle(color: primaryColor, fontWeight: FontWeight.bold)
                : TextStyle(color: Colors.grey.shade600),
          ),
          iconTheme: MaterialStateProperty.resolveWith<IconThemeData>(
            (states) => states.contains(MaterialState.selected)
                ? IconThemeData(color: primaryColor)
                : IconThemeData(color: Colors.grey.shade600),
          ),
        ),
      ),
      child: Scaffold(
        backgroundColor: Colors.grey[100], // A slightly off-white background
        body: IndexedStack( // Use IndexedStack to preserve state of each tab
          index: _selectedIndex,
          children: _pages,
        ),
        bottomNavigationBar: NavigationBar(
          selectedIndex: _selectedIndex,
          onDestinationSelected: (index) {
            setState(() {
              _selectedIndex = index;
            });
          },
          destinations: const [
            NavigationDestination(
              icon: Icon(Icons.home_outlined),
              selectedIcon: Icon(Icons.home),
              label: 'Home',
            ),
            NavigationDestination(
              icon: Icon(Icons.list_alt_outlined),
              selectedIcon: Icon(Icons.list_alt),
              label: 'Pickups',
            ),
            NavigationDestination(
              icon: Icon(Icons.person_outline),
              selectedIcon: Icon(Icons.person),
              label: 'Profile',
            ),
          ],
        ),
      ),
    );
  }
}

// --- LOGOUT DIALOG (MODIFIED FOR FIREBASE) ---
Future<void> _showLogoutConfirmationDialog(BuildContext context) async {
  final navigator = Navigator.of(context);

  return showDialog<void>(
    context: context,
    builder: (BuildContext dialogContext) {
      return AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text('Confirm Logout', style: TextStyle(fontWeight: FontWeight.bold)),
        content: const Text('Are you sure you want to log out?'),
        actions: <Widget>[
          TextButton(
            child: Text('Cancel', style: TextStyle(color: Colors.grey.shade700)),
            onPressed: () => Navigator.of(dialogContext).pop(),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red.shade700,
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            ),
            child: const Text('Logout'),
            onPressed: () async {
              // --- FIREBASE LOGOUT ---
              await FirebaseAuth.instance.signOut();
              
              // The auth listener will navigate to LoginScreen, but this ensures it happens.
              navigator.pushAndRemoveUntil(
                MaterialPageRoute(builder: (context) => const LoginScreen()),
                (Route<dynamic> route) => false,
              );
            },
          ),
        ],
      );
    },
  );
}

// ... CustomerDashboard remains mostly the same, only the logout call changes ...
// --- The complete CustomerDashboard class ---
class CustomerDashboard extends StatelessWidget {
  const CustomerDashboard({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Data for scrap types, making the build method cleaner
    final List<Map<String, dynamic>> scrapTypes = [
      {'name': 'Plastic', 'icon': Icons.water_drop_outlined, 'color': Colors.blue},
      {'name': 'Metal', 'icon': Icons.build_outlined, 'color': Colors.grey.shade700},
      {'name': 'Paper', 'icon': Icons.description_outlined, 'color': Colors.orange},
      {'name': 'E-Waste', 'icon': Icons.devices_other_outlined, 'color': Colors.deepPurple},
    ];

    return Scaffold(
      backgroundColor: Colors.transparent, // Inherits background from parent screen
      appBar: AppBar(
        title: Text(
          'Dashboard',
          style: TextStyle(
            color: Colors.grey.shade900,
            fontWeight: FontWeight.bold,
          ),
        ),
        backgroundColor: Colors.transparent,
        elevation: 0,
        automaticallyImplyLeading: false, // Important for screens in a TabBar/NavBar
        actions: [
          IconButton(
            icon: Icon(Icons.logout, color: Colors.grey.shade700),
            tooltip: 'Logout',
            onPressed: () {
              _showLogoutConfirmationDialog(context); // This now uses Firebase signOut
            },
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildWelcomeCard(context),
            const SizedBox(height: 24),
            _buildScheduleButton(context),
            const SizedBox(height: 24),
            Text(
              'Scrap Types We Collect',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.grey.shade800,
              ),
            ),
            const SizedBox(height: 16),
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 1.2,
              ),
              itemCount: scrapTypes.length,
              itemBuilder: (context, index) {
                final type = scrapTypes[index];
                return _buildScrapTypeCard(
                  type['name'],
                  type['icon'],
                  type['color'],
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  // --- Helper methods for building UI components ---
   Widget _buildWelcomeCard(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20),
        gradient: LinearGradient(
          colors: [Colors.green.shade600, Colors.green.shade800],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.green.shade200,
            blurRadius: 12,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: const [
          Icon(Icons.recycling, size: 40, color: Colors.white),
          SizedBox(height: 16),
          Text(
            'Recycle Smarter, Not Harder',
            style: TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          SizedBox(height: 8),
          Text(
            'Schedule pickups at your convenience and track your contribution.',
            style: TextStyle(fontSize: 15, color: Colors.white70),
          ),
        ],
      ),
    );
  }

  Widget _buildScheduleButton(BuildContext context) {
    return ElevatedButton.icon(
      onPressed: () {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => const SchedulePickupScreen()),
        );
      },
      icon: const Icon(Icons.add_location_alt_outlined, size: 24),
      label: const Text('Schedule New Pickup'),
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.green.shade700,
        foregroundColor: Colors.white,
        padding: const EdgeInsets.symmetric(vertical: 18),
        textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.w600),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        elevation: 4,
        shadowColor: Colors.green.shade200,
      ),
    );
  }

  Widget _buildScrapTypeCard(String name, IconData icon, Color color) {
    return Card(
      elevation: 2,
      shadowColor: Colors.grey.withOpacity(0.2),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: InkWell(
        onTap: () {}, // Can be used for navigation later
        borderRadius: BorderRadius.circular(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            CircleAvatar(
              radius: 24,
              backgroundColor: color.withOpacity(0.15),
              child: Icon(icon, color: color, size: 28),
            ),
            const SizedBox(height: 12),
            Text(
              name,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.grey.shade800,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



class SchedulePickupScreen extends StatefulWidget {
  const SchedulePickupScreen({Key? key}) : super(key: key);

  @override
  State<SchedulePickupScreen> createState() => _SchedulePickupScreenState();
}

class _SchedulePickupScreenState extends State<SchedulePickupScreen> {
  String _selectedType = 'Plastic';
  final _quantityController = TextEditingController();
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  final _addressController = TextEditingController();
  final _pincodeController = TextEditingController();
  DateTime _selectedDate = DateTime.now();
  TimeOfDay _selectedTime = TimeOfDay.now();
  bool _isLoading = false;
  String? _customerCity; // To hold the loaded city of the customer

  @override
  void initState() {
    super.initState();
    _loadCustomerDetails();
  }
  
  @override
  void dispose() {
    _quantityController.dispose();
    _nameController.dispose();
    _phoneController.dispose();
    _addressController.dispose();
    _pincodeController.dispose();
    super.dispose();
  }

  Future<void> _loadCustomerDetails() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    final userDoc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
    
    if (userDoc.exists && mounted) {
      final data = userDoc.data()!;
      setState(() {
        _nameController.text = data['name'] ?? '';
        _phoneController.text = data['phone'] ?? '';
        _addressController.text = data['address'] ?? '';
        _pincodeController.text = data['pincode'] ?? '';
        _customerCity = data['city']; // Load the customer's city from their profile
      });
    }
  }

  Future<void> _schedulePickup() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      _showMessage("You must be logged in to schedule a pickup.");
      return;
    }

    if (_quantityController.text.trim().isEmpty || _nameController.text.trim().isEmpty || 
        _phoneController.text.trim().isEmpty || _addressController.text.trim().isEmpty || 
        _pincodeController.text.trim().isEmpty) {
      _showMessage('Please fill all fields');
      return;
    }

    if (_customerCity == null) {
      _showMessage('Could not find your city. Please update your profile.');
      return;
    }

    setState(() => _isLoading = true);

    try {
      // Create a map of the pickup data, now including the city
      final pickupData = {
        'customerUid': user.uid,
        'customerEmail': user.email,
        'customerName': _nameController.text.trim(),
        'customerPhone': _phoneController.text.trim(),
        'customerAddress': _addressController.text.trim(),
        'customerPincode': _pincodeController.text.trim(),
        'scrapType': _selectedType,
        'quantity': _quantityController.text.trim(),
        'date': Timestamp.fromDate(_selectedDate),
        'time': '${_selectedTime.hour}:${_selectedTime.minute.toString().padLeft(2, '0')}',
        'city': _customerCity, // Add the city to the pickup request document
        'status': 'Pending',
        'captainUid': '',
        'captainEmail': '',
        'createdAt': FieldValue.serverTimestamp(),
      };

      await FirebaseFirestore.instance.collection('pickups').add(pickupData);

      _showMessage('Pickup scheduled successfully!');
      if (mounted) Navigator.pop(context);

    } catch (e) {
      _showMessage('Failed to schedule pickup: $e');
    } finally {
      if(mounted) setState(() => _isLoading = false);
    }
  }

  void _showMessage(String msg) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(msg)),
    );
  }

  Future<void> _selectDate() async {
    final date = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 30)),
    );
    if (date != null) {
      setState(() => _selectedDate = date);
    }
  }

  Future<void> _selectTime() async {
    final time = await showTimePicker(
      context: context,
      initialTime: _selectedTime,
    );
    if (time != null) {
      setState(() => _selectedTime = time);
    }
  }

  @override
  Widget build(BuildContext context) {
    // The UI of this screen does not need to change.
    // The city is handled in the background.
    // The existing build method is perfect.
    return Scaffold(
      appBar: AppBar(
        title: const Text('Schedule Pickup'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Contact Details',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(
                labelText: 'Full Name',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.person),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _phoneController,
              decoration: const InputDecoration(
                labelText: 'Phone Number',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.phone),
              ),
              keyboardType: TextInputType.phone,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _addressController,
              decoration: const InputDecoration(
                labelText: 'Pickup Address',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.home),
              ),
              maxLines: 3,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _pincodeController,
              decoration: const InputDecoration(
                labelText: 'Pincode',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.location_on),
              ),
              keyboardType: TextInputType.number,
            ),
            const SizedBox(height: 24),
            const Divider(),
            const SizedBox(height: 12),
            const Text(
              'Scrap Details',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            DropdownButtonFormField<String>(
              value: _selectedType,
              decoration: const InputDecoration(
                labelText: 'Scrap Type',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.category),
              ),
              items: const [
                DropdownMenuItem(value: 'Plastic', child: Text('Plastic')),
                DropdownMenuItem(value: 'Metal', child: Text('Metal')),
                DropdownMenuItem(value: 'Paper', child: Text('Paper')),
                DropdownMenuItem(value: 'E-Waste', child: Text('E-Waste')),
              ],
              onChanged: (value) {
                setState(() {
                  _selectedType = value!;
                });
              },
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _quantityController,
              decoration: const InputDecoration(
                labelText: 'Quantity (kg)',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.scale),
              ),
              keyboardType: TextInputType.number,
            ),
            const SizedBox(height: 16),
            ListTile(
              title: const Text('Pickup Date'),
              subtitle: Text(
                  '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}'),
              leading: const Icon(Icons.calendar_today),
              trailing: const Icon(Icons.arrow_forward_ios, size: 16),
              shape: RoundedRectangleBorder(
                side: BorderSide(color: Colors.grey.shade400),
                borderRadius: BorderRadius.circular(8),
              ),
              onTap: _selectDate,
            ),
            const SizedBox(height: 16),
            ListTile(
              title: const Text('Pickup Time'),
              subtitle: Text(_selectedTime.format(context)),
              leading: const Icon(Icons.access_time),
              trailing: const Icon(Icons.arrow_forward_ios, size: 16),
              shape: RoundedRectangleBorder(
                side: BorderSide(color: Colors.grey.shade400),
                borderRadius: BorderRadius.circular(8),
              ),
              onTap: _selectTime,
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isLoading ? null : _schedulePickup,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
              child: _isLoading 
                ? const CircularProgressIndicator(color: Colors.white)
                : const Text('Schedule Pickup', style: TextStyle(fontSize: 18)),
            ),
          ],
        ),
      ),
    );
  }
}

// --- CUSTOMER PICKUPS SCREEN (MODIFIED FOR FIRESTORE) ---
class CustomerPickupsScreen extends StatefulWidget {
  const CustomerPickupsScreen({Key? key}) : super(key: key);

  @override
  State<CustomerPickupsScreen> createState() => _CustomerPickupsScreenState();
}

class _CustomerPickupsScreenState extends State<CustomerPickupsScreen> {
  // We no longer need a local list, we will use a Stream
  
  Future<void> _cancelPickup(String docId, String status) async {
    if (status != 'Pending') {
      _showMessage('Cannot cancel: Pickup already $status');
      return;
    }
    try {
      // Delete the document from Firestore
      await FirebaseFirestore.instance.collection('pickups').doc(docId).delete();
      _showMessage('Pickup cancelled successfully');
    } catch(e) {
      _showMessage('Error cancelling pickup: $e');
    }
  }

  void _showMessage(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  Color _getStatusColor(String status) {
    // ... same as before
    switch (status) {
      case 'Pending': return Colors.orange;
      case 'Accepted': return Colors.blue;
      case 'Completed': return Colors.green;
      default: return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('My Pickups'),
        // No manual refresh needed with StreamBuilder
      ),
      // Use a StreamBuilder to listen for real-time updates
      body: user == null
          ? const Center(child: Text("Please log in to see pickups."))
          : StreamBuilder<QuerySnapshot>(
              // Create a stream that queries pickups for the current user
              stream: FirebaseFirestore.instance
                  .collection('pickups')
                  .where('customerUid', isEqualTo: user.uid)
                  .orderBy('createdAt', descending: true)
                  .snapshots(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (snapshot.hasError) {
                  print(">>> FIREBASE ERROR: ${snapshot.error}"); // Add this line!
                  return const Center(child: Text('Something went wrong!'));
                }
                if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
                  return const Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.inbox, size: 80, color: Colors.grey),
                        SizedBox(height: 16),
                        Text('No pickups yet',
                            style: TextStyle(fontSize: 18, color: Colors.grey)),
                      ],
                    ),
                  );
                }

                // If we have data, build the list
                final pickups = snapshot.data!.docs;

                return ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: pickups.length,
                  itemBuilder: (context, index) {
                    final pickupDoc = pickups[index];
                    final pickup = pickupDoc.data() as Map<String, dynamic>;
                    final date = (pickup['date'] as Timestamp).toDate();

                    return Card(
                      margin: const EdgeInsets.only(bottom: 12),
                      child: ListTile(
                        leading: CircleAvatar(
                          backgroundColor:
                              _getStatusColor(pickup['status']).withOpacity(0.2),
                          child: Icon(Icons.recycling,
                              color: _getStatusColor(pickup['status'])),
                        ),
                        title: Text('${pickup['scrapType']} - ${pickup['quantity']} kg'),
                        subtitle: Text(
                          '${date.day}/${date.month}/${date.year} at ${pickup['time']}\nStatus: ${pickup['status']}',
                        ),
                        isThreeLine: true,
                        trailing: pickup['status'] == 'Pending'
                            ? IconButton(
                                icon: const Icon(Icons.cancel, color: Colors.red),
                                onPressed: () {
                                  showDialog(
                                    context: context,
                                    builder: (ctx) => AlertDialog(
                                      title: const Text('Cancel Pickup'),
                                      content: const Text(
                                          'Are you sure you want to cancel this pickup?'),
                                      actions: [
                                        TextButton(
                                          onPressed: () => Navigator.pop(ctx),
                                          child: const Text('No'),
                                        ),
                                        TextButton(
                                          onPressed: () {
                                            Navigator.pop(ctx);
                                            // Pass the document ID to cancel
                                            _cancelPickup(pickupDoc.id, pickup['status']);
                                          },
                                          child: const Text('Yes'),
                                        ),
                                      ],
                                    ),
                                  );
                                },
                              )
                            : null,
                      ),
                    );
                  },
                );
              },
            ),
    );
  }
}


// --- All other screens would be refactored in a similar way ---
// I've refactored all of them for you below.



class CustomerProfileScreen extends StatefulWidget {
  const CustomerProfileScreen({Key? key}) : super(key: key);

  @override
  State<CustomerProfileScreen> createState() => _CustomerProfileScreenState();
}

class _CustomerProfileScreenState extends State<CustomerProfileScreen> {
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  final _addressController = TextEditingController();
  final _pincodeController = TextEditingController();
  String? _selectedCity;
  bool _isEditing = false;
  bool _isLoading = true;

  // Consistent list of cities across the app
  final List<String> _cities = const [
    'Mumbai', 'Delhi', 'Bangalore', 'Kolkata', 'Chennai',
    'Hyderabad', 'Pune', 'Ahmedabad', 'Surat', 'Jaipur',
    'Lucknow', 'Kanpur', 'Nagpur', 'Indore', 'Thane'
  ];

  @override
  void initState() {
    super.initState();
    _loadProfile();
  }
  
  @override
  void dispose() {
    _nameController.dispose();
    _phoneController.dispose();
    _addressController.dispose();
    _pincodeController.dispose();
    super.dispose();
  }

  Future<void> _loadProfile() async {
    setState(() => _isLoading = true);
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if(mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      final doc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
      if (doc.exists && mounted) {
        final data = doc.data()!;
        _nameController.text = data['name'] ?? '';
        _phoneController.text = data['phone'] ?? '';
        _addressController.text = data['address'] ?? '';
        _pincodeController.text = data['pincode'] ?? '';
        setState(() {
          _selectedCity = data['city'];
        });
      }
    } catch (e) {
      _showMessage("Failed to load profile");
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _saveProfile() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    
    if (_selectedCity == null) {
      _showMessage("Please select a city.");
      return;
    }

    setState(() => _isLoading = true);
    try {
      await FirebaseFirestore.instance.collection('users').doc(user.uid).update({
        'name': _nameController.text.trim(),
        'phone': _phoneController.text.trim(),
        'address': _addressController.text.trim(),
        'pincode': _pincodeController.text.trim(),
        'city': _selectedCity, // Save the updated city
      });
      if(mounted) {
        setState(() => _isEditing = false);
        _showMessage('Profile updated successfully!');
      }
    } catch (e) {
      _showMessage('Failed to save profile: $e');
    } finally {
      if(mounted) setState(() => _isLoading = false);
    }
  }

  void _showMessage(String msg) {
    if(!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        actions: [
          if (!_isLoading)
            IconButton(
              icon: Icon(_isEditing ? Icons.save : Icons.edit),
              onPressed: () {
                if (_isEditing) {
                  _saveProfile();
                } else {
                  setState(() => _isEditing = true);
                }
              },
            ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  const CircleAvatar(radius: 50, child: Icon(Icons.person, size: 50)),
                  const SizedBox(height: 24),
                  TextField(
                    controller: _nameController, 
                    enabled: _isEditing, 
                    decoration: const InputDecoration(labelText: 'Name', border: OutlineInputBorder(), prefixIcon: Icon(Icons.person))
                  ),
                  const SizedBox(height: 16),
                  
                  // --- CITY DROPDOWN FOR PROFILE ---
                  DropdownButtonFormField<String>(
                    value: _selectedCity,
                    isExpanded: true,
                    decoration: InputDecoration(
                      labelText: 'City',
                      border: const OutlineInputBorder(),
                      prefixIcon: const Icon(Icons.location_city),
                      filled: !_isEditing, // Gray out when not editing
                      fillColor: _isEditing ? null : Colors.grey[200],
                    ),
                    items: _cities.map((String city) => DropdownMenuItem<String>(value: city, child: Text(city))).toList(),
                    onChanged: _isEditing ? (value) => setState(() => _selectedCity = value) : null, // Disable when not editing
                    validator: (value) => value == null ? 'Please select a city' : null,
                  ),
                  // --- END CITY DROPDOWN ---

                  const SizedBox(height: 16),
                  TextField(
                    controller: _phoneController, 
                    enabled: _isEditing, 
                    keyboardType: TextInputType.phone, 
                    decoration: const InputDecoration(labelText: 'Phone', border: OutlineInputBorder(), prefixIcon: Icon(Icons.phone))
                  ),
                  const SizedBox(height: 16),
                  TextField(
                    controller: _addressController, 
                    enabled: _isEditing, 
                    maxLines: 3, 
                    decoration: const InputDecoration(labelText: 'Address', border: OutlineInputBorder(), prefixIcon: Icon(Icons.home))
                  ),
                  const SizedBox(height: 16),
                  TextField(
                    controller: _pincodeController, 
                    enabled: _isEditing, 
                    keyboardType: TextInputType.number, 
                    decoration: const InputDecoration(labelText: 'Pincode', border: OutlineInputBorder(), prefixIcon: Icon(Icons.location_on))
                  ),
                ],
              ),
            ),
    );
  }
}

// ... CaptainHomeScreen (no changes needed) ...
class CaptainHomeScreen extends StatefulWidget {
  const CaptainHomeScreen({Key? key}) : super(key: key);

  @override
  State<CaptainHomeScreen> createState() => _CaptainHomeScreenState();
}

class _CaptainHomeScreenState extends State<CaptainHomeScreen> {
  int _selectedIndex = 0;

  final List<Widget> _pages = [
    const AvailablePickupsScreen(),
    const ActivePickupsScreen(),
    const CaptainHistoryScreen(),
    const CaptainProfileScreen(), // Add profile screen here
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _pages[_selectedIndex],
      bottomNavigationBar: NavigationBar(
        selectedIndex: _selectedIndex,
        onDestinationSelected: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        destinations: const [
          NavigationDestination(
            icon: Icon(Icons.list_outlined),
            selectedIcon: Icon(Icons.list),
            label: 'Available',
          ),
          NavigationDestination(
            icon: Icon(Icons.local_shipping_outlined),
            selectedIcon: Icon(Icons.local_shipping),
            label: 'Active',
          ),
          NavigationDestination(
            icon: Icon(Icons.history_outlined),
            selectedIcon: Icon(Icons.history),
            label: 'History',
          ),
          NavigationDestination(
            icon: Icon(Icons.person_outline),
            selectedIcon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
      ),
    );
  }
}




class AvailablePickupsScreen extends StatefulWidget {
  const AvailablePickupsScreen({Key? key}) : super(key: key);

  @override
  State<AvailablePickupsScreen> createState() => _AvailablePickupsScreenState();
}

class _AvailablePickupsScreenState extends State<AvailablePickupsScreen> {
  // A future to get the captain's profile data once
  late final Future<DocumentSnapshot> _captainDataFuture;

  @override
  void initState() {
    super.initState();
    // Initialize the future in initState
    _captainDataFuture = _getCaptainData();
  }

  Future<DocumentSnapshot> _getCaptainData() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      throw Exception("User not logged in");
    }
    return FirebaseFirestore.instance.collection('users').doc(user.uid).get();
  }

  Future<void> _acceptPickup(String docId) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    try {
      await FirebaseFirestore.instance.collection('pickups').doc(docId).update({
        'status': 'Accepted',
        'captainUid': user.uid,
        'captainEmail': user.email,
      });
      _showMessage('Pickup accepted successfully!');
    } catch (e) {
      _showMessage('Error accepting pickup: $e');
    }
  }

  void _showMessage(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Available Pickups'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () => _showLogoutConfirmationDialog(context),
          ),
        ],
      ),
      body: FutureBuilder<DocumentSnapshot>(
        future: _captainDataFuture,
        builder: (context, captainSnapshot) {
          if (captainSnapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (captainSnapshot.hasError || !captainSnapshot.hasData || !captainSnapshot.data!.exists) {
            return const Center(child: Text("Could not load captain profile."));
          }

          final captainData = captainSnapshot.data!.data() as Map<String, dynamic>;
          final String? captainCity = captainData['city'];

          if (captainCity == null) {
            return const Center(
              child: Padding(
                padding: EdgeInsets.all(20.0),
                child: Text(
                  "Your city is not set. Please update your profile to see pickups.",
                  textAlign: TextAlign.center,
                ),
              ),
            );
          }

          // Once we have the captain's city, we use a StreamBuilder to listen for pickups
          return StreamBuilder<QuerySnapshot>(
            stream: FirebaseFirestore.instance
                .collection('pickups')
                .where('status', isEqualTo: 'Pending')
                .where('city', isEqualTo: captainCity) // THE KEY FILTER
                .snapshots(),
            builder: (context, pickupSnapshot) {
              if (pickupSnapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator(strokeWidth: 2));
              }
              if (pickupSnapshot.hasError) {
                print(">>> AVAILABLE PICKUPS ERROR: ${pickupSnapshot.error}");
                return const Center(child: Text("Error fetching pickups."));
              }
              if (!pickupSnapshot.hasData || pickupSnapshot.data!.docs.isEmpty) {
                return Center(child: Text('No available pickups in $captainCity.'));
              }

              final pickups = pickupSnapshot.data!.docs;

              return ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: pickups.length,
                itemBuilder: (context, index) {
                  final doc = pickups[index];
                  final pickup = doc.data() as Map<String, dynamic>;
                  final date = (pickup['date'] as Timestamp).toDate();

                  return Card(
                    margin: const EdgeInsets.only(bottom: 12),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              Icon(Icons.recycling, color: Colors.green.shade700),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  '${pickup['scrapType']} - ${pickup['quantity']} kg',
                                  style: const TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 12),
                          const Divider(),
                          const SizedBox(height: 8),
                          // ... the rest of your detailed UI for the card ...
                          const Text( 'Customer Details', style: TextStyle( fontSize: 16, fontWeight: FontWeight.bold, color: Colors.blue,),),
                          const SizedBox(height: 8),
                          Row(children: [const Icon(Icons.person, size: 16), const SizedBox(width: 8), Expanded(child: Text('${pickup['customerName']}')), ],),
                          const SizedBox(height: 4),
                          Row(children: [const Icon(Icons.phone, size: 16), const SizedBox(width: 8), Expanded(child: Text('${pickup['customerPhone']}')), ],),
                          const SizedBox(height: 4),
                          Row(crossAxisAlignment: CrossAxisAlignment.start, children: [const Icon(Icons.home, size: 16), const SizedBox(width: 8), Expanded(child: Text('${pickup['customerAddress']}')), ],),
                          const SizedBox(height: 4),
                          Row(children: [const Icon(Icons.location_on, size: 16), const SizedBox(width: 8), Text('Pincode: ${pickup['customerPincode']}'), ],),
                          const SizedBox(height: 12),
                          const Divider(),
                          const SizedBox(height: 8),
                          Row(children: [const Icon(Icons.calendar_today, size: 16), const SizedBox(width: 8), Text('${date.day}/${date.month}/${date.year}'), const SizedBox(width: 16), const Icon(Icons.access_time, size: 16), const SizedBox(width: 8), Text(pickup['time']), ],),
                          const SizedBox(height: 16),
                          SizedBox(
                            width: double.infinity,
                            child: ElevatedButton.icon(
                              onPressed: () => _acceptPickup(doc.id),
                              icon: const Icon(Icons.check_circle),
                              label: const Text('Accept Pickup'),
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              );
            },
          );
        },
      ),
    );
  }
}

// ... ActivePickupsScreen (Firebase) ...
class ActivePickupsScreen extends StatefulWidget {
  const ActivePickupsScreen({Key? key}) : super(key: key);

  @override
  State<ActivePickupsScreen> createState() => _ActivePickupsScreenState();
}

class _ActivePickupsScreenState extends State<ActivePickupsScreen> {
  Future<void> _completePickup(String docId) async {
     try {
      await FirebaseFirestore.instance.collection('pickups').doc(docId).update({
        'status': 'Completed',
      });
      _showMessage('Pickup completed successfully!');
    } catch(e) {
      _showMessage('Error completing pickup: $e');
    }
  }
  
  void _showMessage(String msg) {
    if(!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return Scaffold(
      appBar: AppBar(title: const Text('Active Pickups')),
      body: user == null
        ? const Center(child: Text("Not Logged In"))
        : StreamBuilder<QuerySnapshot>(
          stream: FirebaseFirestore.instance
              .collection('pickups')
              .where('captainUid', isEqualTo: user.uid)
              .where('status', isEqualTo: 'Accepted')
              .snapshots(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
              return const Center(child: Text('No active pickups.'));
            }

            final pickups = snapshot.data!.docs;

            return ListView.builder(
              itemCount: pickups.length,
              itemBuilder: (context, index) {
                final doc = pickups[index];
                final pickup = doc.data() as Map<String, dynamic>;
                final date = (pickup['date'] as Timestamp).toDate();
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // ... your UI ...
                        Row(
                            children: [
                              Icon(Icons.local_shipping, color: Colors.blue.shade700),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  '${pickup['scrapType']} - ${pickup['quantity']} kg',
                                  style: const TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 12),
                          const Divider(),
                          // ... same detailed UI ...
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton.icon(
                            onPressed: () {
                              showDialog(
                                context: context,
                                builder: (ctx) => AlertDialog(
                                  title: const Text('Complete Pickup'),
                                  content: const Text('Mark this pickup as completed?'),
                                  actions: [
                                    TextButton(onPressed: ()=>Navigator.pop(ctx), child: const Text('Cancel')),
                                    TextButton(
                                      onPressed: (){
                                        Navigator.pop(ctx);
                                        _completePickup(doc.id);
                                      }, 
                                      child: const Text('Complete')),
                                  ],
                                ),
                              );
                            },
                            icon: const Icon(Icons.check_circle),
                            label: const Text('Mark as Completed'),
                            style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            );
          },
        ),
    );
  }
}


// ... CaptainHistoryScreen (Firebase) ...
class CaptainHistoryScreen extends StatefulWidget {
  const CaptainHistoryScreen({Key? key}) : super(key: key);

  @override
  State<CaptainHistoryScreen> createState() => _CaptainHistoryScreenState();
}

class _CaptainHistoryScreenState extends State<CaptainHistoryScreen> {
  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return Scaffold(
      appBar: AppBar(title: const Text('Completed Pickups')),
      body: user == null
        ? const Center(child: Text("Not Logged In"))
        : StreamBuilder<QuerySnapshot>(
          stream: FirebaseFirestore.instance
              .collection('pickups')
              .where('captainUid', isEqualTo: user.uid)
              .where('status', isEqualTo: 'Completed')
              .snapshots(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
              return const Center(child: Text('No completed pickups yet.'));
            }

            final pickups = snapshot.data!.docs;

            return ListView.builder(
              itemCount: pickups.length,
              itemBuilder: (context, index) {
                final doc = pickups[index];
                final pickup = doc.data() as Map<String, dynamic>;
                final date = (pickup['date'] as Timestamp).toDate();
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: ListTile(
                     leading: CircleAvatar(
                        backgroundColor: Colors.green.shade100,
                        child: Icon(Icons.check_circle, color: Colors.green.shade700),
                      ),
                      title: Text('${pickup['scrapType']} - ${pickup['quantity']} kg'),
                      subtitle: Text(
                        '${date.day}/${date.month}/${date.year} at ${pickup['time']}\nCustomer: ${pickup['customerEmail']}',
                      ),
                      isThreeLine: true,
                  ),
                );
              },
            );
          },
        ),
    );
  }
}




class CaptainProfileScreen extends StatefulWidget {
  const CaptainProfileScreen({Key? key}) : super(key: key);

  @override
  State<CaptainProfileScreen> createState() => _CaptainProfileScreenState();
}

class _CaptainProfileScreenState extends State<CaptainProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  final _vehicleNumberController = TextEditingController();
  final _areaController = TextEditingController();
  String? _selectedCity;
  
  bool _isEditing = false;
  bool _isLoading = true;

  // Consistent list of cities across the app
  final List<String> _cities = const [
    'Mumbai', 'Delhi', 'Bangalore', 'Kolkata', 'Chennai',
    'Hyderabad', 'Pune', 'Ahmedabad', 'Surat', 'Jaipur',
    'Lucknow', 'Kanpur', 'Nagpur', 'Indore', 'Thane'
  ];

  @override
  void initState() {
    super.initState();
    _loadProfileData();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _phoneController.dispose();
    _vehicleNumberController.dispose();
    _areaController.dispose();
    super.dispose();
  }

  Future<void> _loadProfileData() async {
    setState(() => _isLoading = true);
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if (mounted) setState(() => _isLoading = false);
      return;
    }

    try {
      // Load general data from 'users' collection
      final userDoc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
      if (userDoc.exists) {
        final data = userDoc.data()!;
        _nameController.text = data['name'] ?? '';
        _phoneController.text = data['phone'] ?? '';
        _selectedCity = data['city'];
      }

      // Load captain-specific data from 'captains' collection
      final captainDoc = await FirebaseFirestore.instance.collection('captains').doc(user.uid).get();
      if (captainDoc.exists) {
        final data = captainDoc.data()!;
        _vehicleNumberController.text = data['vehicleNumber'] ?? '';
        _areaController.text = data['area'] ?? '';
      }
    } catch (e) {
      _showMessage('Error loading profile: $e');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _saveProfile() async {
    if (!_formKey.currentState!.validate()) return;

    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;

    setState(() => _isLoading = true);

    try {
      // Use a batch write to update both documents atomically
      final batch = FirebaseFirestore.instance.batch();

      // Update the 'users' document
      final userDocRef = FirebaseFirestore.instance.collection('users').doc(user.uid);
      batch.set(userDocRef, {
        'name': _nameController.text.trim(),
        'phone': _phoneController.text.trim(),
        'city': _selectedCity,
      }, SetOptions(merge: true));

      // Update the 'captains' document
      final captainDocRef = FirebaseFirestore.instance.collection('captains').doc(user.uid);
      batch.set(captainDocRef, {
        'vehicleNumber': _vehicleNumberController.text.trim().toUpperCase(),
        'area': _areaController.text.trim(),
        'email': user.email, // Good to keep email here too
        'updatedAt': FieldValue.serverTimestamp(),
      }, SetOptions(merge: true));

      await batch.commit();

      if (mounted) {
        setState(() => _isEditing = false);
        _showMessage('Profile updated successfully!');
      }
    } catch (e) {
      _showMessage('Error saving profile: $e');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  void _showMessage(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('My Profile'),
        actions: [
          if (!_isEditing)
            IconButton(
              icon: const Icon(Icons.edit),
              onPressed: () => setState(() => _isEditing = true),
            ),
          if (_isEditing)
             IconButton(
              icon: const Icon(Icons.save),
              onPressed: _isLoading ? null : _saveProfile,
            ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : user == null
              ? const Center(child: Text('Please log in'))
              : SingleChildScrollView(
                  padding: const EdgeInsets.all(16),
                  child: Form(
                    key: _formKey,
                    child: Column(
                      children: [
                        CircleAvatar(radius: 60, backgroundColor: Theme.of(context).primaryColor.withOpacity(0.1), child: Icon(Icons.local_shipping, size: 60, color: Theme.of(context).primaryColor)),
                        const SizedBox(height: 8),
                        Text(_nameController.text.isEmpty ? 'Captain' : _nameController.text, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                        const SizedBox(height: 24),
                        ListTile(leading: const Icon(Icons.email), title: const Text('Email'), subtitle: Text(user.email ?? 'No email')),
                        const SizedBox(height: 16),

                        // Form Fields
                        TextFormField(
                          controller: _nameController, enabled: _isEditing,
                          decoration: const InputDecoration(labelText: 'Full Name', prefixIcon: Icon(Icons.person_outline), border: OutlineInputBorder()),
                          validator: (v) => v!.isEmpty ? 'Name cannot be empty' : null,
                        ),
                        const SizedBox(height: 16),

                        // --- CITY DROPDOWN ---
                        DropdownButtonFormField<String>(
                          value: _selectedCity, isExpanded: true,
                          decoration: InputDecoration(labelText: 'Service City', prefixIcon: const Icon(Icons.location_city), border: const OutlineInputBorder(), filled: !_isEditing, fillColor: Colors.grey[100]),
                          items: _cities.map((city) => DropdownMenuItem(value: city, child: Text(city))).toList(),
                          onChanged: _isEditing ? (value) => setState(() => _selectedCity = value) : null,
                          validator: (v) => v == null ? 'Please select a city' : null,
                        ),
                        const SizedBox(height: 16),

                        TextFormField(
                          controller: _phoneController, enabled: _isEditing, keyboardType: TextInputType.phone,
                          decoration: const InputDecoration(labelText: 'Phone Number', prefixIcon: Icon(Icons.phone_outlined), border: OutlineInputBorder()),
                          validator: (v) => v!.isEmpty || v.length < 10 ? 'Enter a valid phone number' : null,
                        ),
                        const SizedBox(height: 16),
                        TextFormField(
                          controller: _vehicleNumberController, enabled: _isEditing, textCapitalization: TextCapitalization.characters,
                          decoration: const InputDecoration(labelText: 'Vehicle Number', prefixIcon: Icon(Icons.directions_car_outlined), border: OutlineInputBorder()),
                          validator: (v) => v!.isEmpty ? 'Enter vehicle number' : null,
                        ),
                        const SizedBox(height: 16),
                        TextFormField(
                          controller: _areaController, enabled: _isEditing,
                          decoration: const InputDecoration(labelText: 'Service Area (e.g., Suburbs)', prefixIcon: Icon(Icons.map_outlined), border: OutlineInputBorder()),
                          validator: (v) => v!.isEmpty ? 'Enter service area' : null,
                        ),
                        const SizedBox(height: 24),

                        // Save/Cancel Buttons
                        if (_isEditing)
                          Row(
                            children: [
                              Expanded(child: OutlinedButton(onPressed: () => setState(() => _isEditing = false), child: const Text('Cancel'))),
                              const SizedBox(width: 16),
                              Expanded(child: ElevatedButton(onPressed: _isLoading ? null : _saveProfile, child: const Text('Save Profile'))),
                            ],
                          ),
                        
                        const SizedBox(height: 24),
                        if (!_isEditing)
                          SizedBox(
                            width: double.infinity,
                            child: OutlinedButton.icon(
                              onPressed: () => _showLogoutConfirmationDialog(context),
                              icon: const Icon(Icons.logout, color: Colors.red),
                              label: const Text('Logout', style: TextStyle(color: Colors.red)),
                            ),
                          ),
                      ],
                    ),
                  ),
                ),
    );
  }
}


